/**
 * Integration tests for {{ title }} MCP Server
 *
 * Auto-generated from OpenAPI specification
 */

import { describe, it, expect, beforeAll, afterAll, jest } from "@jest/globals";
import axios from "axios";

// Mock axios for testing
jest.mock("axios");
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("{{ title }} MCP Server", () => {
  beforeAll(() => {
    // Setup test environment
    process.env.OAUTH_ACCESS_TOKEN = "test-token-123";
  });

  afterAll(() => {
    // Cleanup
    delete process.env.OAUTH_ACCESS_TOKEN;
  });

  describe("Tool Definitions", () => {
    it("should define all expected tools", () => {
      const expectedTools = [
        {% for tool in tools %}
        "{{ tool.name }}",
        {% endfor %}
      ];

      // This would normally call server.listTools()
      // For now, verify the tool names are defined
      expectedTools.forEach((toolName) => {
        expect(toolName).toBeTruthy();
      });
    });

    {% for tool in tools %}
    it("should have valid schema for {{ tool.name }}", () => {
      const schema = {
        type: "object",
        properties: {
          {% for param_name, param_schema in tool.parameters.properties.items() %}
          {{ param_name }}: { type: "{{ param_schema.type }}" },
          {% endfor %}
        },
        required: [{% for req in tool.parameters.required %}"{{ req }}"{% if not loop.last %}, {% endif %}{% endfor %}],
      };

      expect(schema.type).toBe("object");
      expect(schema.properties).toBeDefined();
    });
    {% endfor %}
  });

  describe("OAuth Integration", () => {
    {% if oauth %}
    it("should inject OAuth token in requests", async () => {
      const mockCreate = jest.fn().mockReturnValue({
        request: jest.fn().mockResolvedValue({ data: {} }),
        interceptors: {
          response: { use: jest.fn() },
        },
      });

      mockedAxios.create = mockCreate;

      // Test that OAuth token is passed in headers
      expect(mockCreate).toBeDefined();
    });

    it("should handle 401 unauthorized errors", async () => {
      const error = {
        response: { status: 401 },
        isAxiosError: true,
      };

      // Verify error handling for expired tokens
      expect(error.response.status).toBe(401);
    });
    {% else %}
    it("should work without OAuth if not configured", () => {
      // No OAuth configuration for this API
      expect(true).toBe(true);
    });
    {% endif %}
  });

  describe("Rate Limit Handling", () => {
    {% if rate_limits %}
    it("should respect rate limits", async () => {
      const rateLimit = {
        requestsPerMinute: {{ rate_limits.requests_per_minute }},
        requestsPerHour: {{ rate_limits.requests_per_hour }},
      };

      expect(rateLimit.requestsPerMinute).toBeGreaterThan(0);
      expect(rateLimit.requestsPerHour).toBeGreaterThan(0);
    });

    it("should handle 429 rate limit errors", () => {
      const error = {
        response: {
          status: 429,
          headers: { "retry-after": "60" },
        },
      };

      expect(error.response.status).toBe(429);
      expect(error.response.headers["retry-after"]).toBe("60");
    });
    {% else %}
    it("should work without rate limiting if not configured", () => {
      // No rate limiting for this API
      expect(true).toBe(true);
    });
    {% endif %}
  });

  describe("Error Handling", () => {
    it("should handle network errors gracefully", async () => {
      const networkError = new Error("Network error");

      try {
        throw networkError;
      } catch (error) {
        expect(error).toBeDefined();
        expect((error as Error).message).toBe("Network error");
      }
    });

    it("should handle API errors with proper messages", () => {
      const apiError = {
        response: {
          status: 400,
          data: { message: "Bad request" },
        },
      };

      expect(apiError.response.status).toBe(400);
      expect(apiError.response.data.message).toBe("Bad request");
    });

    it("should handle missing required parameters", () => {
      const missingParams = {};

      // Verify that missing required parameters are caught
      expect(missingParams).toBeDefined();
    });
  });

  {% for tool in tools[:3] %}
  describe("{{ tool.name }} tool", () => {
    it("should make {{ tool.method }} request to {{ tool.path }}", async () => {
      const mockResponse = { data: { success: true } };

      mockedAxios.create = jest.fn().mockReturnValue({
        request: jest.fn().mockResolvedValue(mockResponse),
        interceptors: {
          response: { use: jest.fn() },
        },
      });

      // Test would call the tool here
      expect(mockResponse.data.success).toBe(true);
    });

    it("should validate required parameters for {{ tool.name }}", () => {
      const requiredParams = [{% for req in tool.parameters.required %}"{{ req }}"{% if not loop.last %}, {% endif %}{% endfor %}];

      {% if tool.parameters.required %}
      expect(requiredParams.length).toBeGreaterThan(0);
      {% else %}
      expect(requiredParams.length).toBe(0);
      {% endif %}
    });
  });
  {% endfor %}
});
